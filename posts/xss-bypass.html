<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XSS Filter Bypass in 2025: Complete Guide to Bypassing WAF and CSP</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-primary: #58a6ff;
            --accent-secondary: #1f6feb;
            --border-color: #30363d;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --code-bg: #161b22;
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f6f8fa;
            --bg-tertiary: #eaeef2;
            --text-primary: #24292f;
            --text-secondary: #57606a;
            --accent-primary: #0969da;
            --accent-secondary: #0550ae;
            --border-color: #d0d7de;
            --success: #1a7f37;
            --warning: #9a6700;
            --danger: #cf222e;
            --code-bg: #f6f8fa;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.8;
            transition: background 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
        }

        .back-link {
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .theme-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .theme-toggle:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }

        .post-header {
            margin-bottom: 50px;
        }

        .post-category {
            display: inline-block;
            padding: 8px 28px;
            background: linear-gradient(135deg, #58a6ff 0%, #1f6feb 100%);
            color: white;
            border-radius: 25px;
            font-size: 0.75rem;
            font-weight: 700;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .post-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: var(--text-primary);
            line-height: 1.2;
        }

        .post-meta {
            display: flex;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 0.9rem;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
        }

        .post-content {
            font-size: 1.05rem;
            line-height: 1.8;
        }

        .post-content h2 {
            font-size: 1.8rem;
            margin: 40px 0 20px 0;
            color: var(--text-primary);
        }

        .post-content h3 {
            font-size: 1.4rem;
            margin: 30px 0 15px 0;
            color: var(--text-primary);
        }

        .post-content p {
            margin-bottom: 20px;
            color: var(--text-secondary);
        }

        .post-content ul, .post-content ol {
            margin: 20px 0;
            padding-left: 30px;
        }

        .post-content li {
            margin-bottom: 10px;
            color: var(--text-secondary);
        }

        .payload-display {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--accent-primary);
            line-height: 1.5;
        }

        .info-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-primary);
            padding: 20px;
            margin: 30px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--warning);
            padding: 20px;
            margin: 30px 0;
            border-radius: 4px;
        }

        .danger-box {
            background: var(--bg-secondary);
            border-left: 4px solid var(--danger);
            padding: 20px;
            margin: 30px 0;
            border-radius: 4px;
        }

        .info-box h4, .warning-box h4, .danger-box h4 {
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            border: 1px solid var(--border-color);
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        th {
            background: var(--bg-tertiary);
            color: var(--accent-primary);
            font-weight: 600;
        }

        tr:hover {
            background: var(--bg-tertiary);
        }

        footer {
            margin-top: 80px;
            padding-top: 30px;
            border-top: 1px solid var(--border-color);
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .post-title {
                font-size: 2rem;
            }

            .post-content h2 {
                font-size: 1.5rem;
            }

            .post-content h3 {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-bar">
            <a href="../index.html" class="back-link">‚Üê Back to Blog</a>
            <button class="theme-toggle" onclick="toggleTheme()">
                <span id="theme-icon">‚òÄÔ∏è</span>
                <span id="theme-text">Light Mode</span>
            </button>
        </div>

        <article>
            <header class="post-header">
                <span class="post-category">WEB SECURITY</span>
                <h1 class="post-title">XSS Filter Bypass in 2025: Complete Guide to Bypassing WAF and CSP</h1>
                <div class="post-meta">
                    <span>Published: Dec 2025</span>
                </div>
            </header>

            <div class="post-content">
                <p>Cross-Site Scripting (XSS) remains the most frequently exploited web vulnerability, ranking number 3 on OWASP's 2025 Top 10. Yet in 2025, XSS is harder than ever to exploit due to sophisticated defenses: Web Application Firewalls (WAFs) block malicious patterns, Content Security Policy (CSP) headers prevent inline script execution, and modern frameworks auto-escape dangerous data. However, skilled attackers continue finding creative ways to bypass these protections. This comprehensive guide covers real-world XSS bypass techniques, contextualized payloads for different scenarios, and methods for discovering blind XSS vulnerabilities.</p>

                <h2>Understanding XSS Defense Mechanisms</h2>

                <h3>1. Web Application Firewalls (WAFs)</h3>
                <p>WAFs use signature-based and behavioral analysis to detect XSS attacks. They operate at the network or application edge and examine requests for known attack patterns. Common WAF limitations include signature-based detection evasion with novel payloads, limited decode passes, rate limiting circumvention, and partial visibility into encrypted HTTPS traffic.</p>

                <h3>2. Content Security Policy (CSP)</h3>
                <p>CSP headers tell the browser which content sources are trusted. A strong CSP blocks inline scripts and restricts external script loading. Example of strong CSP: default-src single-quote-self; script-src single-quote-self https://trusted.cdn.com; object-src single-quote-none.</p>

                <h3>3. Input Validation and Output Encoding</h3>
                <p>Application-level defenses that validate user input and encode output in context-specific ways including HTML encoding, JavaScript encoding, and URL encoding. These are the most effective defenses against XSS.</p>

                <h3>4. Framework Protections</h3>
                <p>Modern frameworks like React, Angular, and Vue auto-escape dangerous data, making DOM-based XSS significantly harder to exploit.</p>

                <h2>XSS Bypass Techniques</h2>

                <h3>1. Double Encoding (WAF Bypass)</h3>
                <p>Many WAFs decode input once. Double encoding bypasses single-pass filtering. When you double-encode dangerous characters, the WAF sees safe content on first decode, but the browser decodes it again during rendering, executing the payload.</p>

                <div class="payload-display">Example of double encoding:
First pass: Convert less-than to ampersand hash x 3 C
Second pass: Convert that entire sequence again
WAF sees safe content, browser executes payload
                </div>

                <h3>2. Case Manipulation</h3>
                <p>WAF rules often fail on mixed-case payloads because signature detection is case-sensitive.</p>

                <div class="payload-display">Blocked: script tag with alert
Bypasses: ScRiPt tag with alert (mixed case)
                </div>

                <h3>3. Alternative HTML Tags and Event Handlers</h3>
                <p>Instead of using script tags, attackers use SVG, audio, video, and other HTML5 elements with event handlers.</p>

                <h4>SVG-based attacks:</h4>
                <p>SVG elements support onload handlers and can execute JavaScript. For example: svg tag with onload event handler.</p>

                <h4>HTML5 Media Tags:</h4>
                <p>Audio and video tags support various event handlers like ontimeupdate and onerror.</p>

                <h4>Other less common tags:</h4>
                <p>Body tag, marquee tag, details tag, and input tag can all execute JavaScript through various event handlers.</p>

                <h3>4. JavaScript Protocol and Data URIs</h3>
                <p>Using javascript: protocol in href attributes or data: URIs with embedded HTML and scripts. These bypass many traditional XSS filters.</p>

                <h3>5. CSS-based XSS</h3>
                <p>CSS can execute JavaScript through expression injection and URL-based handlers. Modern browsers have mitigated much of this, but some edge cases remain.</p>

                <h3>6. Attribute-based Injection</h3>
                <p>Breaking out of restricted attributes by injecting quotes and new event handlers. For example, if an application allows img tags but restricts onerror, you can break out of the src attribute to inject your own onerror handler.</p>

                <h3>7. Framework-Specific Bypasses</h3>

                <h4>AngularJS Vulnerabilities:</h4>
                <p>AngularJS expression injection allows executing arbitrary code through template syntax like double curly braces with constructor calls.</p>

                <h4>React DOM Issues:</h4>
                <p>The dangerouslySetInnerHTML prop allows rendering raw HTML. If user input reaches this prop without sanitization, XSS occurs. Developers must never pass unsanitized user input to dangerouslySetInnerHTML.</p>

                <h3>8. Context-Based Payloads</h3>

                <h4>In HTML Context:</h4>
                <p>Direct HTML injection with img src x onerror alert or svg onload alert.</p>

                <h4>In JavaScript Context:</h4>
                <p>Breaking out of strings with quotes and semicolons to inject new JavaScript statements. Using template literals to inject code.</p>

                <h4>In URL Context:</h4>
                <p>Using javascript: protocol, data: URIs, or vbscript: (IE only) to execute code.</p>

                <h2>Blind XSS Detection Methods</h2>

                <h3>What is Blind XSS?</h3>
                <p>Blind XSS occurs when your payload executes but you cannot see the result in the immediate response. Common examples include feedback forms, contact pages, admin panels, and support ticket systems where user input is stored and later viewed by administrators.</p>

                <h3>Detection Approach</h3>

                <h4>Step 1: Set Up Out-of-Band Listener</h4>
                <p>Create a listener to receive callbacks when your payload executes. Options include Burp Collaborator (built into Burp Suite Pro), webhook.site (free webhook testing), or custom serverless solutions.</p>

                <h4>Step 2: Inject Payloads at Blind Points</h4>
                <p>Target inputs that are stored and viewed later by admins or other users. Common injection points include feedback forms, profile comments, support tickets, user-agent headers, referer headers, and file upload metadata.</p>

                <h4>Step 3: Monitor for Callbacks</h4>
                <p>Wait for your listener to receive a request. Each request confirms code execution and may contain exfiltrated data like cookies, session tokens, or page content.</p>

                <h3>Blind XSS Tools</h3>
                <ul>
                    <li>Xless: Serverless Blind XSS app with Slack notifications and screenshot capture</li>
                    <li>BeeXSS: Automated Blind XSS detection tool with Selenium automation</li>
                    <li>GoHunt: Golang Blind XSS hunter with XSSHunter-like functionality</li>
                    <li>Burp Collaborator: Built-in out-of-band detection in Burp Suite Pro</li>
                    <li>Webhook.site: Free webhook testing for vulnerability detection</li>
                </ul>

                <h2>CSP Bypass Techniques</h2>

                <h3>Dangerous CSP Configurations</h3>

                <h4>CSP allows unsafe-inline:</h4>
                <p>If a CSP allows unsafe-inline for scripts, inline script execution is possible. This completely defeats CSP protection.</p>

                <h4>CSP allows data URIs:</h4>
                <p>If CSP allows data: protocol for scripts, you can embed HTML and JavaScript directly in data URIs.</p>

                <h4>CSP with wildcard domains:</h4>
                <p>If CSP trusts wildcard domains like asterisk.example.com, attackers can upload malicious scripts to subdomains and load them.</p>

                <h3>Vulnerabilities in Allowed Domains</h3>
                <p>If CSP trusts jQuery CDN, exploit jQuery vulnerabilities or use jQuery plugins with callback parameters for XSS. Many CDN services have vulnerable endpoints that can be abused even when the domain is trusted by CSP.</p>

                <h2>Comprehensive XSS Payload Categories</h2>

                <table>
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Use Case</th>
                            <th>Defense</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Reflected XSS</td>
                            <td>Immediate execution in current page</td>
                            <td>Output encoding</td>
                        </tr>
                        <tr>
                            <td>Stored XSS</td>
                            <td>Persisted in database, affects all users</td>
                            <td>Input sanitization plus output encoding</td>
                        </tr>
                        <tr>
                            <td>DOM XSS</td>
                            <td>JavaScript manipulation of DOM</td>
                            <td>Use textContent instead of innerHTML</td>
                        </tr>
                        <tr>
                            <td>Blind XSS</td>
                            <td>Execution not visible to attacker</td>
                            <td>RASP, CSP monitoring, output encoding</td>
                        </tr>
                        <tr>
                            <td>UXSS</td>
                            <td>Cross-origin script execution</td>
                            <td>SOP enforcement in browsers</td>
                        </tr>
                    </tbody>
                </table>

                <h2>Comprehensive XSS Payload Collection</h2>

                <div class="info-box">
                    <h4>üì• Download Payloads File</h4>
                    <p>We have compiled a comprehensive list of XSS payloads organized by category, including basic payloads, encoding techniques, WAF bypasses, blind XSS, data exfiltration, and more. All payloads are displayed as plain text to prevent any execution in your browser.</p>
                    <p><strong>File Location:</strong> <code>/resources/xss-payloads.txt</code></p>
                    <p><strong><a href="../resources/xss-payloads.txt" style="color: #58a6ff; text-decoration: underline;">Download XSS Payloads List (TXT)</a></strong></p>
                    <p>This file contains over 200+ XSS payloads organized by category including:</p>
                    <ul style="margin-top: 10px; margin-left: 20px;">
                        <li>Basic XSS payloads</li>
                        <li>Encoding techniques (HTML, Unicode, Hex, Base64)</li>
                        <li>Case manipulation and comment bypass</li>
                        <li>SVG and HTML5 media tag payloads</li>
                        <li>WAF-specific bypasses (Cloudflare, Akamai, ModSecurity)</li>
                        <li>Blind XSS detection payloads</li>
                        <li>Out-of-band data exfiltration</li>
                        <li>Cookie stealing and credential harvesting</li>
                        <li>CSRF exploitation payloads</li>
                        <li>Context-specific payloads (HTML, JavaScript, URL, CSS)</li>
                    </ul>
                </div>

                <h3>Automated Tools for XSS Detection</h3>
                <ul>
                    <li>XSSStrike: Advanced XSS scanner with payload mutation and smart detection</li>
                    <li>Dalfox: Powerful XSS scanner written in Go with domain parsing</li>
                    <li>XSSGAI: AI-powered payload generator that creates novel payloads</li>
                    <li>PayloadsAllTheThings: GitHub repository with comprehensive payload examples</li>
                    <li>Burp Suite: Professional web security testing platform with XSS detection</li>
                </ul>

                <h3>Manual Testing Process</h3>
                <ol>
                    <li>Identify user input points that are reflected or stored</li>
                    <li>Test basic payloads to confirm XSS vulnerability exists</li>
                    <li>If blocked, try encoding, case manipulation, and alternative tags</li>
                    <li>Test in different contexts: HTML, JavaScript, URLs, CSS</li>
                    <li>For blind XSS, set up listener and inject with callbacks</li>
                    <li>Document payload, context, browser compatibility, and impact</li>
                </ol>

                <h2>Best Practices for XSS Testing</h2>

                <ul>
                    <li>Always test in authorized environments only</li>
                    <li>Understand the application context and data flow</li>
                    <li>Try multiple payload variations when initial attempts fail</li>
                    <li>Document all successful payloads and bypass techniques discovered</li>
                    <li>Report findings with clear impact and remediation steps</li>
                    <li>Follow responsible disclosure practices</li>
                </ul>

                <div class="danger-box">
                    <h4>Legal Warning</h4>
                    <p>XSS testing should ONLY be conducted on systems you own or have explicit written authorization to test. Unauthorized XSS exploitation is illegal under computer fraud laws. Always ensure you have proper scope, authorization letters, and clear rules of engagement before conducting any security assessment.</p>
                </div>

                <h2>Conclusion</h2>
                <p>XSS in 2025 remains a critical vulnerability despite improved defenses. WAFs can be bypassed, CSP can be misconfigured, and frameworks have edge cases. The emergence of AI-powered payload generators demonstrates that traditional signature-based defenses are becoming obsolete. Successful XSS exploitation requires understanding context, knowing bypass techniques, and persistence in testing. Blind XSS adds complexity where attackers can exploit vulnerabilities without seeing immediate results.</p>

                <p>The key takeaway is that XSS prevention must be multi-layered. Combine input validation, output encoding that is context-specific, strong CSP implementation, RASP technology, and runtime monitoring. No single defense is sufficient in 2025. Organizations must implement defense-in-depth strategies to protect against modern XSS attacks.</p>
            </div>
        </article>

        <footer>
            <p>¬© 2025 SBOW Infosec. All research for educational purposes only.</p>
        </footer>
    </div>

    <script>
        function toggleTheme() {
            const html = document.documentElement;
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            const currentTheme = html.getAttribute('data-theme');
            
            if (currentTheme === 'light') {
                html.removeAttribute('data-theme');
                themeIcon.textContent = '‚òÄÔ∏è';
                themeText.textContent = 'Light Mode';
                localStorage.setItem('theme', 'dark');
            } else {
                html.setAttribute('data-theme', 'light');
                themeIcon.textContent = 'üåô';
                themeText.textContent = 'Dark Mode';
                localStorage.setItem('theme', 'light');
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme');
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            
            if (savedTheme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
                themeIcon.textContent = 'üåô';
                themeText.textContent = 'Dark Mode';
            }
        });
    </script>
</body>
</html>
